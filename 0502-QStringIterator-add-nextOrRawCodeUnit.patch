From 233d624c1949428df495504248b124b761b083d6 Mon Sep 17 00:00:00 2001
From: Marc Mutz <marc.mutz@qt.io>
Date: Tue, 21 Oct 2025 12:10:36 +0200
Subject: [PATCH 502/553] QStringIterator: add nextOrRawCodeUnit()
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

While fixing Clang 21 -Wcharacter-conversion warnings, I came across
many code snippets that used a pattern like

    char32_t ucs4 = string[i];
    if (QChar::isHighSurrogate(ucs4) && i + 1 != len) {
        ushort low = string[i + 1];
        if (QChar::isLowSurrogate(low)) {
            ucs4 = QChar::surrogateToUcs4(ucs4, low);
            ++i;
        }
    }

(this one from qunicodetools.cpp)

The natural question is why this was never ported to QStringIterator,
and the answer is: because QStringIterator doesn't support this.

Add new functions nextOrRawCodeUnit() (and previousOrRawCodeUnit()),
to fix this shortcoming.

The name of the functions is chosen so that it will work also in a
future UTF-8 string iterator.

Add tests that verify that the old code and the new functions produce
the same series of code points.

Pick-to: 6.8 6.5
Change-Id: I34ba8e416ee290badc1c16e33b46a17d56741574
Reviewed-by: Ahmad Samir <a.samirh78@gmail.com>
Reviewed-by: Thiago Macieira <thiago.macieira@intel.com>
Reviewed-by: MÃ¥rten Nordheim <marten.nordheim@qt.io>
(cherry picked from commit bb7f82a410971bc73e2ac4d10cf6c285ddee9e42)
Reviewed-by: Qt Cherry-pick Bot <cherrypick_bot@qt-project.org>
---
 src/corelib/text/qstringiterator_p.h          | 22 +++++++
 .../qstringiterator/tst_qstringiterator.cpp   | 61 +++++++++++++++++++
 2 files changed, 83 insertions(+)

diff --git a/src/corelib/text/qstringiterator_p.h b/src/corelib/text/qstringiterator_p.h
index 38a1216bdb8..3c9658bd92f 100644
--- a/src/corelib/text/qstringiterator_p.h
+++ b/src/corelib/text/qstringiterator_p.h
@@ -148,6 +148,17 @@ public:
         return uc.unicode();
     }
 
+    char32_t nextOrRawCodeUnit()
+    {
+        Q_ASSERT_X(hasNext(), Q_FUNC_INFO, "iterator hasn't a next item");
+
+        const QChar uc = *pos++;
+        if (uc.isHighSurrogate() && hasNext() && pos->isLowSurrogate())
+            return QChar::surrogateToUcs4(uc, *pos++);
+
+        return uc.unicode();
+    }
+
     // backwards iteration
 
     inline bool hasPrevious() const
@@ -228,6 +239,17 @@ public:
 
         return uc.unicode();
     }
+
+    char32_t previousOrRawCodeUnit()
+    {
+        Q_ASSERT_X(hasPrevious(), Q_FUNC_INFO, "iterator hasn't a previous item");
+
+        const QChar uc = *--pos;
+        if (uc.isLowSurrogate() && hasPrevious() && pos[-1].isHighSurrogate())
+            return QChar::surrogateToUcs4(*--pos, uc);
+
+        return uc.unicode();
+    }
 };
 
 QT_END_NAMESPACE
diff --git a/tests/auto/corelib/text/qstringiterator/tst_qstringiterator.cpp b/tests/auto/corelib/text/qstringiterator/tst_qstringiterator.cpp
index 22bff24eec0..c0a67840c75 100644
--- a/tests/auto/corelib/text/qstringiterator/tst_qstringiterator.cpp
+++ b/tests/auto/corelib/text/qstringiterator/tst_qstringiterator.cpp
@@ -11,6 +11,8 @@ class tst_QStringIterator : public QObject
 private slots:
     void sweep_data();
     void sweep();
+    void nextOrRawCodeUnitEquivalenceWithOldCode_data() { sweep_data(); }
+    void nextOrRawCodeUnitEquivalenceWithOldCode();
 
     void position();
 };
@@ -253,6 +255,65 @@ void tst_QStringIterator::sweep()
     }
 }
 
+void tst_QStringIterator::nextOrRawCodeUnitEquivalenceWithOldCode()
+{
+    QFETCH(const QString, string);
+    // QFETCH(bool, valid);
+
+    const auto s = string.data_ptr().data(); // avoids QChar
+
+    // this is the old code, used before we had nextOrRawCodeUnit():
+    const auto oldResult = [&] {
+        QList<char32_t> result;
+        result.reserve(string.size());
+
+        const auto len = string.size();
+        for (qsizetype i = 0; i < len; ++i) {
+            QT_WARNING_PUSH
+            QT_WARNING_DISABLE_CLANG("-Wcharacter-conversion")
+            char32_t ucs4;
+            const char16_t c = s[i];
+            if (QChar::isHighSurrogate(c) && i + 1 < len && QChar::isLowSurrogate(s[i + 1]))
+                ucs4 = QChar::surrogateToUcs4(c, s[++i]);
+            else
+                ucs4 = c;
+            QT_WARNING_POP
+            result.push_back(ucs4);
+        }
+        return result;
+    }();
+
+    // now the same with nextOrRawCodeUnit():
+    const auto newResult = [&] {
+        QList<char32_t> result;
+        result.reserve(string.size());
+
+        QStringIterator it(string);
+        while (it.hasNext())
+            result.push_back(it.nextOrRawCodeUnit());
+
+        return result;
+    }();
+
+    // they should yield the equivalent series of code points:
+    QCOMPARE_EQ(newResult, oldResult);
+
+    // also check next/previousOrRawCodeUnit() consistency:
+    const auto fromBack = [&] {
+        QList<char32_t> result;
+        result.reserve(string.size());
+
+        QStringIterator it(string, string.size());
+        while (it.hasPrevious())
+            result.push_back(it.previousOrRawCodeUnit());
+
+        std::reverse(result.begin(), result.end());
+        return result;
+    }();
+
+    QCOMPARE_EQ(fromBack, newResult);
+}
+
 void tst_QStringIterator::position()
 {
     static const QChar stringData[] =
-- 
2.51.2

