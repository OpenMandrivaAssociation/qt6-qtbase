From cbc92d43f3600cbdcc313cd5924155930349a9d7 Mon Sep 17 00:00:00 2001
From: Ahmad Samir <a.samirh78@gmail.com>
Date: Thu, 2 Oct 2025 19:49:40 +0300
Subject: [PATCH 551/553] QTimer: fix clang -Wshorten-64-to-32 warnings

std::chrono::milliseconds::count() does not return int, so assigning
the result to an int variable triggers said warning. Fix by using
q26::saturate_cast<int> and checking (or asserting) that the value
didn't change.

Amends 1ca89b65d85c5df971fac7c1f9d5678e0e0cf45b.

Pick-to: 6.8
Change-Id: I419c931d04b533402335568cc2e9569cc627f117
Reviewed-by: Marc Mutz <marc.mutz@qt.io>
Reviewed-by: Thiago Macieira <thiago.macieira@intel.com>
(cherry picked from commit 75bb26261bf66c9beda84a6aad54bcd272b8d4dc)
Reviewed-by: Qt Cherry-pick Bot <cherrypick_bot@qt-project.org>
---
 src/corelib/kernel/qtimer.cpp | 27 ++++++++++++++++-----------
 1 file changed, 16 insertions(+), 11 deletions(-)

diff --git a/src/corelib/kernel/qtimer.cpp b/src/corelib/kernel/qtimer.cpp
index afc6bab8559..319ae8bc24e 100644
--- a/src/corelib/kernel/qtimer.cpp
+++ b/src/corelib/kernel/qtimer.cpp
@@ -15,6 +15,8 @@
 #include "qproperty_p.h"
 #include "qthread.h"
 
+#include <q26numeric.h> // for q26::staturate_cast
+
 using namespace std::chrono_literals;
 
 QT_BEGIN_NAMESPACE
@@ -248,19 +250,21 @@ void QTimer::start(int msec)
     start(msec * 1ms);
 }
 
-static std::chrono::milliseconds
+static int
 checkInterval(const char *caller, std::chrono::milliseconds interval)
 {
-    constexpr auto maxInterval = INT_MAX * 1ms;
     if (interval < 0ms) {
         qWarning("%s: negative intervals aren't allowed; the interval will be set to 1ms.", caller);
-        interval = 1ms;
-    } else if (interval > maxInterval) {
+        return 1;
+    }
+
+    const auto msec = interval.count();
+    int ret = q26::saturate_cast<int>(msec);
+    if (ret != msec) {
         qWarning("%s: interval exceeds maximum allowed interval, it will be clamped to "
                  "INT_MAX ms (about 24 days).", caller);
-        interval = maxInterval;
     }
-    return interval;
+    return ret;
 }
 
 /*!
@@ -288,8 +292,7 @@ void QTimer::start(std::chrono::milliseconds interval)
 {
     Q_D(QTimer);
 
-    interval = checkInterval("QTimer::start", interval);
-    const int msec = interval.count();
+    const int msec = checkInterval("QTimer::start", interval);
     const bool intervalChanged = msec != d->inter;
     d->inter.setValue(msec);
     start();
@@ -656,8 +659,7 @@ void QTimer::setInterval(std::chrono::milliseconds interval)
 {
     Q_D(QTimer);
 
-    interval = checkInterval("QTimer::setInterval", interval);
-    const int msec = interval.count();
+    const int msec = checkInterval("QTimer::setInterval", interval);
     d->inter.removeBindingUnlessInWrapper();
     const bool intervalChanged = msec != d->inter.valueBypassingBindings();
     d->inter.setValueBypassingBindings(msec);
@@ -705,7 +707,10 @@ int QTimer::remainingTime() const
     if (d->isActive()) {
         using namespace std::chrono;
         auto remaining = QAbstractEventDispatcher::instance()->remainingTime(d->id);
-        return ceil<milliseconds>(remaining).count();
+        const auto msec = ceil<milliseconds>(remaining).count();
+        const int ret = q26::saturate_cast<int>(msec);
+        Q_ASSERT(ret == msec); // cannot overflow because the interval is clamped before it's set
+        return ret;
     }
 
     return -1;
-- 
2.51.2

