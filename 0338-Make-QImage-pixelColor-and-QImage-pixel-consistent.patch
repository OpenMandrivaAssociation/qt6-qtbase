From ecd06ab31e17efbb58c6af9da52b259788ccc7ce Mon Sep 17 00:00:00 2001
From: Allan Sandfeld Jensen <allan.jensen@qt.io>
Date: Thu, 9 Oct 2025 11:59:49 +0200
Subject: [PATCH 338/553] Make QImage::pixelColor and QImage::pixel consistent
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

A few opaque colors were using a short cut that could cause it to
read alpha values inconsistent with QImage::pixel behavior on RGB32

Pick-to: 6.8 6.5
Change-Id: I64b78036c0f8b3d5f60ca1fc53accd2df40c1018
Reviewed-by: Tor Arne Vestb√∏ <tor.arne.vestbo@qt.io>
(cherry picked from commit f6124944e464c96e4d2ba0291cc3f53f27451b77)
Reviewed-by: Qt Cherry-pick Bot <cherrypick_bot@qt-project.org>
---
 src/gui/image/qimage.cpp | 43 +++++++++++++++++++++++++++++++---------
 1 file changed, 34 insertions(+), 9 deletions(-)

diff --git a/src/gui/image/qimage.cpp b/src/gui/image/qimage.cpp
index 684d66121d6..19397024e94 100644
--- a/src/gui/image/qimage.cpp
+++ b/src/gui/image/qimage.cpp
@@ -2525,41 +2525,52 @@ QRgb QImage::pixel(int x, int y) const
         }
         return d->colortable.at(index);
     }
-
+    std::optional<QRgb> out;
     switch (d->format) {
     case Format_RGB32:
-        return 0xff000000 | reinterpret_cast<const QRgb *>(s)[x];
     case Format_ARGB32: // Keep old behaviour.
     case Format_ARGB32_Premultiplied:
-        return reinterpret_cast<const QRgb *>(s)[x];
+        out = reinterpret_cast<const QRgb *>(s)[x];
+        break;
     case Format_RGBX8888:
     case Format_RGBA8888: // Match ARGB32 behavior.
     case Format_RGBA8888_Premultiplied:
-        return RGBA2ARGB(reinterpret_cast<const quint32 *>(s)[x]);
+        out = RGBA2ARGB(reinterpret_cast<const quint32 *>(s)[x]);
+        break;
     case Format_BGR30:
     case Format_A2BGR30_Premultiplied:
-        return qConvertA2rgb30ToArgb32<PixelOrderBGR>(reinterpret_cast<const quint32 *>(s)[x]);
+        out = qConvertA2rgb30ToArgb32<PixelOrderBGR>(reinterpret_cast<const quint32 *>(s)[x]);
+        break;
     case Format_RGB30:
     case Format_A2RGB30_Premultiplied:
-        return qConvertA2rgb30ToArgb32<PixelOrderRGB>(reinterpret_cast<const quint32 *>(s)[x]);
+        out = qConvertA2rgb30ToArgb32<PixelOrderRGB>(reinterpret_cast<const quint32 *>(s)[x]);
+        break;
     case Format_RGB16:
         return qConvertRgb16To32(reinterpret_cast<const quint16 *>(s)[x]);
     case Format_RGBX64:
     case Format_RGBA64: // Match ARGB32 behavior.
     case Format_RGBA64_Premultiplied:
-        return reinterpret_cast<const QRgba64 *>(s)[x].toArgb32();
+        out = reinterpret_cast<const QRgba64 *>(s)[x].toArgb32();
+        break;
     case Format_RGBX16FPx4:
     case Format_RGBA16FPx4: // Match ARGB32 behavior.
     case Format_RGBA16FPx4_Premultiplied:
-        return reinterpret_cast<const QRgbaFloat16 *>(s)[x].toArgb32();
+        out = reinterpret_cast<const QRgbaFloat16 *>(s)[x].toArgb32();
+        break;
     case Format_RGBX32FPx4:
     case Format_RGBA32FPx4: // Match ARGB32 behavior.
     case Format_RGBA32FPx4_Premultiplied:
-        return reinterpret_cast<const QRgbaFloat32 *>(s)[x].toArgb32();
+        out = reinterpret_cast<const QRgbaFloat32 *>(s)[x].toArgb32();
     default:
         break;
     }
     const QPixelLayout *layout = &qPixelLayouts[d->format];
+    if (out) {
+        // Fix up alpha
+        if (!layout->hasAlphaChannel)
+            *out |= 0xff000000;
+        return *out;
+    }
     uint result;
     return *layout->fetchToARGB32PM(&result, s, x, 1, nullptr, nullptr);
 }
@@ -2744,6 +2755,8 @@ QColor QImage::pixelColor(int x, int y) const
         QRgbaFloat16 p = reinterpret_cast<const QRgbaFloat16 *>(s)[x];
         if (d->format == Format_RGBA16FPx4_Premultiplied)
             p = p.unpremultiplied();
+        else if (d->format == Format_RGBX16FPx4)
+            p.setAlpha(1.0f);
         QColor color;
         color.setRgbF(p.red(), p.green(), p.blue(), p.alpha());
         return color;
@@ -2754,6 +2767,8 @@ QColor QImage::pixelColor(int x, int y) const
         QRgbaFloat32 p = reinterpret_cast<const QRgbaFloat32 *>(s)[x];
         if (d->format == Format_RGBA32FPx4_Premultiplied)
             p = p.unpremultiplied();
+        else if (d->format == Format_RGBX32FPx4)
+            p.setAlpha(1.0f);
         QColor color;
         color.setRgbF(p.red(), p.green(), p.blue(), p.alpha());
         return color;
@@ -2762,6 +2777,16 @@ QColor QImage::pixelColor(int x, int y) const
         c = QRgba64::fromArgb32(pixel(x, y));
         break;
     }
+    // Alpha fix up
+    switch (d->format) {
+    case Format_BGR30:
+    case Format_RGB30:
+    case Format_RGBX64:
+        c.setAlpha(65535);
+        break;
+    default:
+        break;
+    }
     // QColor is always unpremultiplied
     if (hasAlphaChannel() && qPixelLayouts[d->format].premultiplied)
         c = c.unpremultiplied();
-- 
2.51.2

