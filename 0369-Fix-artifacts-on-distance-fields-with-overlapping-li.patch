From f632583fb9f24ceae7f41389bd153abe2348cc4d Mon Sep 17 00:00:00 2001
From: Eskil Abrahamsen Blomfeldt <eskil.abrahamsen-blomfeldt@qt.io>
Date: Thu, 9 Oct 2025 14:30:16 +0200
Subject: [PATCH 369/553] Fix artifacts on distance fields with overlapping
 lines

The latest version of Noto Sans CJK JP has some very small
bugs where a tiny line segments extend from the outline and then
return immediately with an overlapping line (e.g. one line with
a normal of (0, 1) first and then another line with a normal of
(0, -1) right after it).

The way distance field generation works is that it will first
flatten curves into line segments. Then it will gradient fill
rectangles around these line segments, aligned with the normals.

If there is an angle between the line segments, there will be
gaps between these rectangles, so we then need to fill these in
with triangles.

There are two different code paths for the triangles: One if
the angle between the two line segments is convex and one if
not.

For parallel lines, there is no gap to fill, but we would still
execute the triangle pass for concave in this case, as parallel
lines were considered non-convex. This broke down for these
overlapping lines, causing large smudges of fully interior
pixels to be drawn over the position of the overlapping lines.

Since we know that parallel lines will not require the fill
triangles, we can bypass this step entirely if the line segments
are parallel, which eliminates this issue.

Fixes: QTBUG-139610
Change-Id: I18c5480630ae667f511843881b1243628d9a17c5
Reviewed-by: Eirik Aavitsland <eirik.aavitsland@qt.io>
(cherry picked from commit ad7a9155c1b855ed6e06929fb283254910059231)
Reviewed-by: Qt Cherry-pick Bot <cherrypick_bot@qt-project.org>
---
 src/gui/text/qdistancefield.cpp | 14 ++++++++------
 1 file changed, 8 insertions(+), 6 deletions(-)

diff --git a/src/gui/text/qdistancefield.cpp b/src/gui/text/qdistancefield.cpp
index f4dca6185bc..c77c0004be8 100644
--- a/src/gui/text/qdistancefield.cpp
+++ b/src/gui/text/qdistancefield.cpp
@@ -495,7 +495,8 @@ static void makeDistanceField(QDistanceFieldData *data, const QPainterPath &path
     const quint32 *indices = pathIndices.data();
     QVarLengthArray<QPoint> normals;
     QVarLengthArray<QPoint> vertices;
-    QVarLengthArray<bool> isConvex;
+
+    QVarLengthArray<int> crossProducts;
     QVarLengthArray<bool> needsClipping;
 
     drawPolygons(bits.data(), imgWidth, imgHeight, pathVertices.data(),
@@ -536,10 +537,10 @@ static void makeDistanceField(QDistanceFieldData *data, const QPainterPath &path
                                  || (to.y() < offs << 8) || (to.y() >= (imgHeight - offs) << 8));
         }
 
-        isConvex.resize(normals.size());
+        crossProducts.resize(normals.size());
         for (int next = 0, prev = normals.size() - 1; next < normals.size(); prev = next++) {
-            isConvex[prev] = normals.at(prev).x() * normals.at(next).y()
-                           - normals.at(prev).y() * normals.at(next).x() < 0;
+            crossProducts[prev] = normals.at(prev).x() * normals.at(next).y()
+                                - normals.at(prev).y() * normals.at(next).x();
         }
 
         // Draw quads.
@@ -571,7 +572,8 @@ static void makeDistanceField(QDistanceFieldData *data, const QPainterPath &path
                                       exteriorColor);
             }
 
-            if (isConvex.at(prev)) {
+            const int crossProduct = crossProducts.at(prev);
+            if (crossProduct < 0) {
                 QPoint p = extPrev;
                 if (needsClipping[prev]) {
                     for (;;) {
@@ -612,7 +614,7 @@ static void makeDistanceField(QDistanceFieldData *data, const QPainterPath &path
                         extPrev = p;
                     }
                 }
-            } else {
+            } else if (crossProduct > 0) {
                 QPoint p = intPrev;
                 if (needsClipping[prev]) {
                     for (;;) {
-- 
2.51.2

