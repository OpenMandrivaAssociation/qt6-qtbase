From 6bcb1a43da8f623de4c5027d3d980166c64ea8b5 Mon Sep 17 00:00:00 2001
From: Ahmad Samir <a.samirh78@gmail.com>
Date: Wed, 13 Aug 2025 16:10:25 +0300
Subject: [PATCH 260/553] tst_QObject: add tests for string-based connect() for
 invokables

The string-based {dis,}connect() work with methods registered with the
meta-object system, which includes invokables. The SLOT() macro at the
moment works with both slots (Q_SLOTS:) and invokable methods, which may
be considered a bug; only a function marked as a slot should be found by
the SLOT() macro.

Q_INVOKABLE has no effect on a signal, moc will register it as a signal
not just a "method". Extend the tests to show that.

Task-number: QTBUG-139128
Pick-to: 6.9 6.8
Change-Id: Ic62197ab840d5fdeb75ce3da804109d3d969d8a1
Reviewed-by: Thiago Macieira <thiago.macieira@intel.com>
(cherry picked from commit 7f6d53808964140e9606be372883427053e5523b)
Reviewed-by: Qt Cherry-pick Bot <cherrypick_bot@qt-project.org>
---
 .../corelib/kernel/qobject/tst_qobject.cpp    | 108 +++++++++++++++++-
 1 file changed, 102 insertions(+), 6 deletions(-)

diff --git a/tests/auto/corelib/kernel/qobject/tst_qobject.cpp b/tests/auto/corelib/kernel/qobject/tst_qobject.cpp
index a68fac7d0a1..70c3d9843d2 100644
--- a/tests/auto/corelib/kernel/qobject/tst_qobject.cpp
+++ b/tests/auto/corelib/kernel/qobject/tst_qobject.cpp
@@ -47,6 +47,7 @@ class tst_QObject : public QObject
     Q_OBJECT
 private slots:
     void disconnect();
+    void connect_signalToSignal();
     void connectSlotsByName();
     void connectSignalsToSignalsWithDefaultArguments();
     void receivers();
@@ -190,6 +191,9 @@ public:
     void emitSignal2() { emit signal2(); }
     void emitSignal3() { emit signal3(); }
     void emitSignal4() { emit signal4(); }
+    void emitSignal7() { emit signal7(7, u"foo"_s); }
+    void emitSignalInvoke1() { emit signalInvoke1(); }
+    void emitSignalSinvoke1() { emit signalSinvoke1(); }
 
 signals:
     void signal1();
@@ -199,6 +203,8 @@ signals:
     QT_MOC_COMPAT void signal5();
     void signal6(void);
     void signal7(int, const QString &);
+    void signalInvoke1();
+    void signalSinvoke1();
 
 public slots:
     void aPublicSlot() { aPublicSlotCalled++; }
@@ -227,12 +233,7 @@ class ReceiverObject : public QObject
     Q_OBJECT
 
 public:
-    ReceiverObject()
-        : sequence_slot1( 0 )
-        , sequence_slot2( 0 )
-        , sequence_slot3( 0 )
-        , sequence_slot4( 0 )
-    {}
+    ReceiverObject() { reset(); }
 
     void reset()
     {
@@ -240,20 +241,34 @@ public:
         sequence_slot3 = 0;
         sequence_slot2 = 0;
         sequence_slot1 = 0;
+        sequence_invoke1 = 0;
+        sequence_sinvoke1 = 0;
+        sequence_receiverSignal7_invokable = 0;
+
         count_slot1 = 0;
         count_slot2 = 0;
         count_slot3 = 0;
         count_slot4 = 0;
+        count_invoke1 = 0;
+        count_sinvoke1 = 0;
+        count_receiverSignal7_invokable = 0;
     }
 
     int sequence_slot1;
     int sequence_slot2;
     int sequence_slot3;
     int sequence_slot4;
+    int sequence_invoke1;
+    int sequence_sinvoke1;
+    int sequence_receiverSignal7_invokable;
+
     int count_slot1;
     int count_slot2;
     int count_slot3;
     int count_slot4;
+    int count_invoke1;
+    int count_sinvoke1;
+    int count_receiverSignal7_invokable;
 
     bool called(int slot)
     {
@@ -262,18 +277,32 @@ public:
         case 2: return sequence_slot2;
         case 3: return sequence_slot3;
         case 4: return sequence_slot4;
+        case 5: return sequence_invoke1;
+        case 6: return sequence_sinvoke1;
+        case 7: return sequence_receiverSignal7_invokable;
         default: return false;
         }
     }
 
     static int sequence;
 
+    Q_INVOKABLE void slotInvoke1() { sequence_invoke1 = ++sequence; ++count_invoke1; }
+    Q_SCRIPTABLE void slotSinvoke1() { sequence_sinvoke1 = ++sequence; ++count_sinvoke1; }
+
 public slots:
     void slot1() { sequence_slot1 = ++sequence; count_slot1++; }
     void slot2() { sequence_slot2 = ++sequence; count_slot2++; }
     void slot3() { sequence_slot3 = ++sequence; count_slot3++; }
     void slot4() { sequence_slot4 = ++sequence; count_slot4++; }
+    void slot7(int, const QString &)
+    {
+        sequence_receiverSignal7_invokable = ++sequence;
+        ++count_receiverSignal7_invokable;
+    }
 
+Q_SIGNALS:
+    // Q_INVOKABLE is no-op here, moc will register this as a signal
+    Q_INVOKABLE void receiverSignal7_invokable(int, const QString &);
 };
 
 int ReceiverObject::sequence = 0;
@@ -304,16 +333,22 @@ void tst_QObject::disconnect()
     connect(&s, SIGNAL(signal2()), &r1, SLOT(slot2()));
     connect(&s, SIGNAL(signal3()), &r1, SLOT(slot3()));
     connect(&s, SIGNAL(signal4()), &r1, SLOT(slot4()));
+    connect(&s, SIGNAL(signalInvoke1()), &r1, SLOT(slotInvoke1()));
+    connect(&s, SIGNAL(signalSinvoke1()), &r1, SLOT(slotSinvoke1()));
 
     s.emitSignal1();
     s.emitSignal2();
     s.emitSignal3();
     s.emitSignal4();
+    s.emitSignalInvoke1();
+    s.emitSignalSinvoke1();
 
     QVERIFY(r1.called(1));
     QVERIFY(r1.called(2));
     QVERIFY(r1.called(3));
     QVERIFY(r1.called(4));
+    QVERIFY(r1.called(5));
+    QVERIFY(r1.called(6));
     r1.reset();
 
     // usual disconnect with all parameters given
@@ -328,6 +363,15 @@ void tst_QObject::disconnect()
     ret = QObject::disconnect(&s, SIGNAL(signal1()), &r1, SLOT(slot1()));
     QVERIFY(!ret);
 
+    QObject::disconnect(&s, SIGNAL(signalInvoke1()), &r1, SLOT(slotInvoke1()));
+    QObject::disconnect(&s, SIGNAL(signalSinvoke1()), &r1, SLOT(slotSinvoke1()));
+
+    s.emitSignalInvoke1();
+    s.emitSignalSinvoke1();
+
+    QVERIFY(!r1.called(5));
+    QVERIFY(!r1.called(6));
+
     // disconnect all signals from s from all slots from r1
     QObject::disconnect(&s, 0, &r1, 0);
 
@@ -400,6 +444,58 @@ void tst_QObject::disconnect()
     QVERIFY(s.disconnect());
 }
 
+void tst_QObject::connect_signalToSignal()
+{
+    SenderObject sender;
+    ReceiverObject receiver;
+
+    connect(&sender, SIGNAL(signal1()), &receiver, SLOT(slot1()));
+    connect(&sender, SIGNAL(signal2()), &receiver, SLOT(slot2()));
+
+    connect(&sender, SIGNAL(signal1()), &sender, SIGNAL(signal2()));
+    sender.emitSignal1();
+
+    QVERIFY(receiver.called(1));
+    QVERIFY(receiver.called(2));
+
+
+    bool res = QObject::disconnect(&sender, SIGNAL(signal1()), &sender, SIGNAL(signal2()));
+    QVERIFY(res);
+
+    receiver.reset();
+    sender.emitSignal1();
+    QVERIFY(receiver.called(1));
+    QVERIFY(!receiver.called(2));
+
+    receiver.reset();
+    // This is to update the count/sequence of receiverSignal7_invokable
+    connect(&receiver, SIGNAL(receiverSignal7_invokable(int,const QString&)),
+            &receiver, SLOT(slot7(int,const QString&)));
+
+    connect(&sender, SIGNAL(signal7(int,const QString&)),
+            &receiver, SIGNAL(receiverSignal7_invokable(int,const QString&)));
+    sender.emitSignal7();
+    QVERIFY(receiver.called(7));
+
+    res = QObject::disconnect(&sender, SIGNAL(signal7(int,const QString&)),
+                              &receiver, SIGNAL(receiverSignal7_invokable(int,const QString&)));
+    QVERIFY(res);
+    receiver.reset();
+    sender.emitSignal7();
+    QVERIFY(!receiver.called(7));
+
+    receiver.reset();
+    static const auto re = QRegularExpression("QObject::connect: No such slot "
+                           "ReceiverObject::receiverSignal7_invokable\\(int,const QString&\\).*");
+    QTest::ignoreMessage(QtWarningMsg, re);
+    // Q_INVOKABLE in receiverSignal7_invokable() declaration is no-op, moc
+    // registers this as a signal, consequently it only works with the SIGNAL()
+    // macro in connect() calls
+    auto connection = connect(&sender, SIGNAL(signal7(int,const QString&)),
+                              &receiver, SLOT(receiverSignal7_invokable(int,const QString&)));
+    QVERIFY(!connection);
+}
+
 class AutoConnectSender : public QObject
 {
     Q_OBJECT
-- 
2.51.2

