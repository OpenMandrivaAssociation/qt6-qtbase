From 49462414570c126f815de6ccce3216ea5891638a Mon Sep 17 00:00:00 2001
From: Laszlo Agocs <laszlo.agocs@qt.io>
Date: Thu, 7 Aug 2025 11:51:49 +0200
Subject: [PATCH 300/553] Windows with D3D: Guard vsync update deliveries more
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Flip m_vsyncUpdatePending back to "ready" only on the
gui thread, when the queued metacall is processed.
Also have a third state, "posted", to indicate that
the invokeMethod call has been made but not yet
processed on the gui thread.

Otherwise certain Quick applications can end up in
a situation where there are an ever growing number
of metacalls queued, not having the chance to
process them all if new requestUpdate() calls are
made continuously as a reaction to Qt Quick doing
a new frame.

Done-with: Christian Strømme <christian.stromme@qt.io>
Fixes: QTBUG-139014
Pick-to: 6.9
Change-Id: I1ae4f28ee6a52d66cc4349bf930c5e873a7e299c
Reviewed-by: Christian Strømme <christian.stromme@qt.io>
(cherry picked from commit 456fb97ddc4c606999c5468e063fe1c6f59c4408)
Reviewed-by: Qt Cherry-pick Bot <cherrypick_bot@qt-project.org>
---
 src/plugins/platforms/windows/qwindowswindow.cpp | 14 ++++++++++++--
 1 file changed, 12 insertions(+), 2 deletions(-)

diff --git a/src/plugins/platforms/windows/qwindowswindow.cpp b/src/plugins/platforms/windows/qwindowswindow.cpp
index 12f34eec265..5781ac77f32 100644
--- a/src/plugins/platforms/windows/qwindowswindow.cpp
+++ b/src/plugins/platforms/windows/qwindowswindow.cpp
@@ -3997,14 +3997,24 @@ QString QWindowsWindow::formatWindowTitle(const QString &title)
 
 void QWindowsWindow::requestUpdate()
 {
+    enum UpdateState {
+        Ready = 0,
+        Requested = 1,
+        Posted = 2
+    };
     QWindow *w = window();
     QDxgiVSyncService *vs = QDxgiVSyncService::instance();
     if (vs->supportsWindow(w)) {
         if (m_vsyncServiceCallbackId == 0) {
             m_vsyncServiceCallbackId = vs->registerCallback([this, w](const QDxgiVSyncService::CallbackWindowList &windowList, qint64) {
                 if (windowList.contains(w)) {
-                    if (m_vsyncUpdatePending.testAndSetAcquire(1, 0)) {
+                    // Make sure we only post one event at a time. If the state
+                    // isn't Requested, it means there either isn't a pending
+                    // request or we are waiting for the event loop to process
+                    // the Posted event on the GUI thread.
+                    if (m_vsyncUpdatePending.testAndSetAcquire(UpdateState::Requested, UpdateState::Posted)) {
                         QMetaObject::invokeMethod(w, [this, w] {
+                            m_vsyncUpdatePending.storeRelease(UpdateState::Ready);
                             if (w->handle() == this)
                                 deliverUpdateRequest();
                         });
@@ -4012,7 +4022,7 @@ void QWindowsWindow::requestUpdate()
                 }
             });
         }
-        m_vsyncUpdatePending.storeRelease(1);
+        m_vsyncUpdatePending.testAndSetRelease(UpdateState::Ready, UpdateState::Requested);
     } else {
         QPlatformWindow::requestUpdate();
     }
-- 
2.51.2

