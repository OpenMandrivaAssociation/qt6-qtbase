From 46bbfb3818b63152df2d24ff0801d1f89249f653 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Tor=20Arne=20Vestb=C3=B8?= <tor.arne.vestbo@qt.io>
Date: Mon, 13 Oct 2025 17:51:05 +0200
Subject: [PATCH 510/553] macOS: Map function keys by their virtual key code,
 not MacRoman chars
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

When mapping incoming key events to their possible key combinations
for shortcut mapping we use UCKeyTranslate, or its modern Cocoa
equivalent [NSEvent charactersByApplyingModifiers:] (which plumbs
to UCKeyTranslate internally).

When doing so for function keys, we get back characters codes such
as 0x01 / ␁ / Start of Heading when pressing the Home key,
or 0x04 / ␄ / End of Transmission when pressing the End key,
which map to kHomeCharCode and kEndCharCode correspondingly
in the MacRoman character codes table from HIToolBox's Events.h

We used these MacRoman character code mappings to turn kHomeCharCode
into Qt::Key_Home and kEndCharCode into Qt::Key_End.

Surprisingly UCKeyTranslate/charactersByApplyingModifiers does
not return the equivalent function key character codes from the
NSEvent.h header, such as NSEndFunctionKey, even if the original
NSEvent we're processing has this as the NSEvent.characters or
NSEvent.charactersIgnoringModifiers, as reported here:

  https://developer.apple.com/forums/thread/803439

This is a problem because key events with the Control (^) key
also (naturally) map to these character codes when fed through
UCKeyTranslate, which resulted in matching shortcuts for Qt::Key_Home
and Qt::Key_End if the user pressed Control+A or Control+D. Or even
worse, if users had shortcuts registered for Ctrl+A and Home, or
Ctrl+D and End, at the same time, these shortcuts would be
considered ambiguous.

To fix this we now map function keys via the keyboard layout
independent virtual key codes from the same HIToolBox Events.h
header, which ensures we only map real function keys during to
Qt::Keys such as Qt::Key_End.

Note that we still consider the keyboard-layout-mapped character
codes for functions keys coming from NSEvent.h, in case there are
layouts that explicitly map to these.

Fixes: QTBUG-134441
Pick-to: 6.8
Change-Id: Iac8def7540247665562b438bf4af06b4347d33b0
Reviewed-by: Doris Verria <doris.verria@qt.io>
(cherry picked from commit 4a09c6d82990044fc35a59f28466b9c28e3df3bf)
Reviewed-by: Qt Cherry-pick Bot <cherrypick_bot@qt-project.org>
---
 src/gui/platform/darwin/qapplekeymapper.mm | 153 +++++++++------------
 1 file changed, 68 insertions(+), 85 deletions(-)

diff --git a/src/gui/platform/darwin/qapplekeymapper.mm b/src/gui/platform/darwin/qapplekeymapper.mm
index 214865864ff..49f7a8ff0cb 100644
--- a/src/gui/platform/darwin/qapplekeymapper.mm
+++ b/src/gui/platform/darwin/qapplekeymapper.mm
@@ -94,60 +94,10 @@ static CarbonModifiers toCarbonModifiers(Qt::KeyboardModifiers qtModifiers)
     return carbonModifiers;
 }
 
-// Keyboard keys (non-modifiers)
-static QHash<char16_t, Qt::Key> standardKeys = {
-    { kHomeCharCode, Qt::Key_Home },
-    { kEnterCharCode, Qt::Key_Enter },
-    { kEndCharCode, Qt::Key_End },
-    { kBackspaceCharCode, Qt::Key_Backspace },
-    { kTabCharCode, Qt::Key_Tab },
-    { kPageUpCharCode, Qt::Key_PageUp },
-    { kPageDownCharCode, Qt::Key_PageDown },
-    { kReturnCharCode, Qt::Key_Return },
-    { kEscapeCharCode, Qt::Key_Escape },
-    { kLeftArrowCharCode, Qt::Key_Left },
-    { kRightArrowCharCode, Qt::Key_Right },
-    { kUpArrowCharCode, Qt::Key_Up },
-    { kDownArrowCharCode, Qt::Key_Down },
-    { kHelpCharCode, Qt::Key_Help },
-    { kDeleteCharCode, Qt::Key_Delete },
-    // ASCII maps, for debugging
-    { ':', Qt::Key_Colon },
-    { ';', Qt::Key_Semicolon },
-    { '<', Qt::Key_Less },
-    { '=', Qt::Key_Equal },
-    { '>', Qt::Key_Greater },
-    { '?', Qt::Key_Question },
-    { '@', Qt::Key_At },
-    { ' ', Qt::Key_Space },
-    { '!', Qt::Key_Exclam },
-    { '"', Qt::Key_QuoteDbl },
-    { '#', Qt::Key_NumberSign },
-    { '$', Qt::Key_Dollar },
-    { '%', Qt::Key_Percent },
-    { '&', Qt::Key_Ampersand },
-    { '\'', Qt::Key_Apostrophe },
-    { '(', Qt::Key_ParenLeft },
-    { ')', Qt::Key_ParenRight },
-    { '*', Qt::Key_Asterisk },
-    { '+', Qt::Key_Plus },
-    { ',', Qt::Key_Comma },
-    { '-', Qt::Key_Minus },
-    { '.', Qt::Key_Period },
-    { '/', Qt::Key_Slash },
-    { '[', Qt::Key_BracketLeft },
-    { ']', Qt::Key_BracketRight },
-    { '\\', Qt::Key_Backslash },
-    { '_', Qt::Key_Underscore },
-    { '`', Qt::Key_QuoteLeft },
-    { '{', Qt::Key_BraceLeft },
-    { '}', Qt::Key_BraceRight },
-    { '|', Qt::Key_Bar },
-    { '~', Qt::Key_AsciiTilde },
-    { '^', Qt::Key_AsciiCircum }
-};
-
-static QHash<char16_t, Qt::Key> virtualKeys = {
+// NSEvent.keyCode codes for keys that are independent of keyboard layout.
+// Some of these are technically possible to add custom key maps for, but
+// doing so would be unexpected.
+static QHash<char16_t, Qt::Key> layoutIndependentKeyCodes = {
     { kVK_F1, Qt::Key_F1 },
     { kVK_F2, Qt::Key_F2 },
     { kVK_F3, Qt::Key_F3 },
@@ -164,16 +114,57 @@ static QHash<char16_t, Qt::Key> virtualKeys = {
     { kVK_F14, Qt::Key_F14 },
     { kVK_F15, Qt::Key_F15 },
     { kVK_F16, Qt::Key_F16 },
+    { kVK_F17, Qt::Key_F17 },
+    { kVK_F18, Qt::Key_F18 },
+    { kVK_F19, Qt::Key_F19 },
+    { kVK_F20, Qt::Key_F20 },
+
     { kVK_Return, Qt::Key_Return },
     { kVK_Tab, Qt::Key_Tab },
+    { kVK_Space, Qt::Key_Space },
     { kVK_Escape, Qt::Key_Escape },
-    { kVK_Help, Qt::Key_Help },
+    { kVK_Delete, Qt::Key_Backspace },
+    { kVK_ForwardDelete, Qt::Key_Delete },
+
+    { kVK_Home, Qt::Key_Home },
+    { kVK_End, Qt::Key_End },
+    { kVK_PageUp, Qt::Key_PageUp },
+    { kVK_PageDown, Qt::Key_PageDown },
+
     { kVK_UpArrow, Qt::Key_Up },
     { kVK_DownArrow, Qt::Key_Down },
     { kVK_LeftArrow, Qt::Key_Left },
     { kVK_RightArrow, Qt::Key_Right },
-    { kVK_PageUp, Qt::Key_PageUp },
-    { kVK_PageDown, Qt::Key_PageDown }
+
+    { kVK_CapsLock, Qt::Key_CapsLock },
+    { kVK_Shift, Qt::Key_Shift },
+    { kVK_RightShift, Qt::Key_Shift },
+
+#if 0
+    // FIXME: Map these here instead of relying on
+    // custom logic in [QNSView flagsChanged:]
+
+    { kVK_Command, Qt::Key_unknown },
+    { kVK_RightCommand, Qt::Key_unknown },
+    { kVK_Option, Qt::Key_unknown },
+    { kVK_RightOption, Qt::Key_unknown },
+    { kVK_Control, Qt::Key_unknown },
+    { kVK_RightControl, Qt::Key_unknown },
+    { kVK_Function, Qt::Key_unknown },
+#endif
+
+    { kVK_VolumeUp, Qt::Key_VolumeUp },
+    { kVK_VolumeDown, Qt::Key_VolumeDown },
+    { kVK_Mute, Qt::Key_VolumeMute },
+
+#if 0
+    // FIXME: Figure out which Qt::Key this maps to
+    { kVK_ContextualMenu, Qt::Key_unknown },
+#endif
+    { kVK_Help, Qt::Key_Help },
+
+    { kVK_ANSI_KeypadClear, Qt::Key_Clear },
+    { kVK_ANSI_KeypadEnter, Qt::Key_Enter },
 };
 
 static QHash<char16_t, Qt::Key> functionKeys = {
@@ -211,41 +202,19 @@ static int toKeyCode(const QChar &key, int virtualKey, int modifiers)
     qCDebug(lcQpaKeyMapperKeys, "Mapping key: %d (0x%04x) / vk %d (0x%04x)",
         key.unicode(), key.unicode(), virtualKey, virtualKey);
 
-    if (key == char16_t(kClearCharCode) && virtualKey == 0x47)
-        return Qt::Key_Clear;
-
-    if (key.isDigit()) {
-        qCDebug(lcQpaKeyMapperKeys, "Got digit key: %d", key.digitValue());
-        return key.digitValue() + Qt::Key_0;
-    }
-
-    if (key.isLetter()) {
-        qCDebug(lcQpaKeyMapperKeys, "Got letter key: %d", (key.toUpper().unicode() - 'A'));
-        return (key.toUpper().unicode() - 'A') + Qt::Key_A;
-    }
-    if (key.isSymbol()) {
-        qCDebug(lcQpaKeyMapperKeys, "Got symbol key: %d", (key.unicode()));
-        return key.unicode();
-    }
-
-    if (auto qtKey = standardKeys.value(key.unicode())) {
+    // Check first if we have a virtual key that should be treated as layout
+    // independent. If so, we want to return early without inspecting the key.
+    if (auto qtKey = layoutIndependentKeyCodes.value(virtualKey)) {
+        qCDebug(lcQpaKeyMapperKeys) << "Got" << qtKey << "based on layout independent virtual key";
         // To work like Qt for X11 we issue Backtab when Shift + Tab are pressed
         if (qtKey == Qt::Key_Tab && (modifiers & Qt::ShiftModifier)) {
-            qCDebug(lcQpaKeyMapperKeys, "Got key: Qt::Key_Backtab");
+            qCDebug(lcQpaKeyMapperKeys, "Transformed into Qt::Key_Backtab");
             return Qt::Key_Backtab;
         }
-
-        qCDebug(lcQpaKeyMapperKeys) << "Got" << qtKey;
-        return qtKey;
-    }
-
-    // Last ditch try to match the scan code
-    if (auto qtKey = virtualKeys.value(virtualKey)) {
-        qCDebug(lcQpaKeyMapperKeys) << "Got scancode" << qtKey;
         return qtKey;
     }
 
-    // Check if they belong to key codes in private unicode range
+    // Then check if the key is one of the functions keys in the private Unicode range
     if (key >= char16_t(NSUpArrowFunctionKey) && key <= char16_t(NSModeSwitchFunctionKey)) {
         if (auto qtKey = functionKeys.value(key.unicode())) {
             qCDebug(lcQpaKeyMapperKeys) << "Got" << qtKey;
@@ -257,6 +226,20 @@ static int toKeyCode(const QChar &key, int virtualKey, int modifiers)
         }
     }
 
+    if (key.isDigit()) {
+        qCDebug(lcQpaKeyMapperKeys, "Got digit key: %d", key.digitValue());
+        return key.digitValue() + Qt::Key_0;
+    }
+
+    if (key.isLetter()) {
+        qCDebug(lcQpaKeyMapperKeys, "Got letter key: %d", (key.toUpper().unicode() - 'A'));
+        return (key.toUpper().unicode() - 'A') + Qt::Key_A;
+    }
+    if (key.isSymbol()) {
+        qCDebug(lcQpaKeyMapperKeys, "Got symbol key: %d", (key.unicode()));
+        return key.unicode();
+    }
+
     qCDebug(lcQpaKeyMapperKeys, "Unknown case.. %d[%d] %d", key.unicode(), key.toLatin1(), virtualKey);
     return Qt::Key_unknown;
 }
-- 
2.51.2

